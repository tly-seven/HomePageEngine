---
title: "P4：对交互式信息可视化的可移植并行处理管道"
cover: "/images/blogs/vis/P43.png"
tags: ["数据可视化", "TVCG"]
date: 2018-10-08T16:32:32+08:00
---

经典可视化库，如 D3，通常提供了高表现力的声明式编程语法，这有利于提高可视化的开发生产力。然而，这些库却很少提供对高性能计算的支持。当需要处理海量数据时，可视化的速度和性能往往不令人满意。而本文提出了 P4，这是一个高性能、高生产力、高度灵活、高度可移植的可视化技术。简单的说，P4 = D3 + GPU，适用于海量大数据的高性能可视化场景。

<!--more-->

[原文链接：P4: Portable Parallel Processing Pipelines for Interactive Information Visualization](/files/papers/P4.pdf)

# 一、介绍
- 背景：
	- 数据可视化
	- 多核并行处理器
- 问题：
	- 如何有效利用并行硬件（尤其是 GPU）来提升可视化性能，包括数据处理和可视化渲染
- 现状：
	- 许多可视化工具的声明式语法提供了高表现力，有利于提高开发生产力
	- 大部分可视化工具缺乏对高性能的支持
- 解决方案：P4
	- 性能：GPU 计算，加速数据处理和可视化渲染
	- 生产力：易用的编程抽象
	- 可编程性：高度抽象会限制可编程性，P4 允许用户自定义的逻辑
	- 可移植性：基于 WebGL 的标准图形学 API，适用不同类型的处理内核和 GPU，可以和不同技术和库无缝衔接
- 评估

# 二、相关工作
- 本工作致力于缩小可视化工具在表现力和性能之间的差距，结合声明式语法和高性能可视化技术。

## 2.1 可视化和图形学工具
- 许多可视化库都提供声明式语法，然而没有考虑高性能
	- 基础：The Grammar of Graphics
	- 可视化工具：ggplot2、Protovis、D3
	- 交互：Vega、Vega-Lite
- GPU 计算，缺点是对交互可视化开发缺乏效率
	- GPGPU 技术：GPU 上的通用计算方法。不仅限于图形计算，扩大到普适高性能计算领域。
	- 普遍方法是，使用内嵌了数据转化和可视化算法的图形学 API， 例如，OpenGL 和 WebGL。
	- 然而图形学 API 进行数据转化是困难的（在点和像素空间表达数据）。
	- 另一种方法是，使用 GPGPU API 进行数据转化，例如 Open CL 和 CUDA；使用图形学 API 进行可视化。
	- 然而这需要熟悉两种 API 及其中的互操作。即便有一些方便的 GPGPU 库，例如 Thrust、Boost.Compute
- 信息可视化社区的备选方法
	- Towards utilizing gpus in information visualization: A model and implementation of image-space operations
	- 提出了一个带有 UI 的可视编程环境，用于组合 GPU 着色器以创建数据可视化。缺点是不够灵活。
	- Stardust: Accessible and transparent gpu support for information visualization rendering
	- 提供一个类似于 D3 的编程接口，用 WebGL 渲染大数据。缺点是只关注渲染、不支持数据转化。

## 2.2 高性能可视化技术
- 常见的高性能可视化技术：
	- 数据缩减技术：过滤、采样、数据立方，缺点是减少了对数据的深入挖掘
	- 分布式系统和云计算：Spotfire、Tableau，缺点是大数据网络传输成本（常包含服务端计算和客户端渲染）
	- CPU 的多线程和并行计算：缺点是性能不如 GPU
	- Cache 数据缓存
	- 增量可视化：对不适应系统内存的大型数据集，渐进式可视化
- P4 的应用：
	- GPU 并行计算：基于许多图形学可视化研究基础，通过着色器编程，生成 GPU 运行时代码
	- GPU Cache：在 GPU 内存中缓存和管理数据，而不是在计算机内存

# 三、设计
## 3.1 系统模型
![](/images/blogs/vis/P41.png)

## 3.2 数据模型
- 存储：
	- 存储、管理和操作于 GPU 内存
	- 列顺序，相同数据维度的值相互邻接。为了便于 GPU 内存的高效读取。

## 3.3 执行模型
- 并行、顺序

# 四、编程接口
- 展示的例子包含 20 万条记录

## 4.1 数据转化
- 三种操作：
	- Derive：用户定义逻辑，从已存在的属性计算出一个新属性
	- Match：匹配满足条件的记录
	- Aggregate：基于统计方法汇集数据
- 综合三种操作的例子

	![](/images/blogs/vis/P42.png)
	
- 一些别的例子

	![](/images/blogs/vis/P43.png)
	![](/images/blogs/vis/P44.png)
	![](/images/blogs/vis/P45.png)

## 4.2 可视化映射
- 将数据属性或转化的结果映射到可视编码通道

## 4.3 交互
- 交互：一对事件和响应
	- 事件：包括点击、悬停、刷选、缩放、平移
	- 响应：可视化对于事件的反应，改变可视编码

![](/images/blogs/vis/P46.png)

## 4.4 控制流
- 作用：用于管理复杂工作流
	- Register 操作，中间结果的缓存
	- Resume 操作，改变当前状态和数据输入到初始设置
	- Export 操作，导出数据处理结果


## 4.5 感知增强
- 作用：防止大量的标记绘制引起的视觉混乱
- 方式：根据标记的密度和空间分布调整不透明度和颜色
- 基础：基于 Liu 等人提出的感知增强技术，immens: Real-time visual querying of big data(CGF 2013)
- 公式：
	- p 代表当前像素的标记重叠数量
	- p(max) 代表整个视图的标记重叠数量
	- y 默认为 1/3，因为立方根可以更好的近似感知线性
	- a(min) 默认为 0.1，基于根据之前的实验得出的感知透明度
	![](/images/blogs/vis/P47.png)
- 比较结果：第一种不能展示热点区，第三种产生高度不确定性
	- 左：WebGL alpha blending
	- 中：P4 opacity adjustment
	- 右：Data binning technique
	![](/images/blogs/vis/P48.png)
- 另一个比较：
	- 左：WebGL alpha blending
	- 中：P4 opacity adjustment
	- 右：P4 color mapping
	![](/images/blogs/vis/P49.png)

# 五、并行处理框架
![](/images/blogs/vis/P410.png)


## 5.1 数据并行原语
- 大部分复杂的操作都可以归纳为功能性的编程原语
	- Map
	- Filter
	- Reduce：用于计算统计聚集值
- 还需要一个有效的获取数据的原语
	- Fetch：基于 P4 存储机制和 ID，计算数据在 GPU 存储的位置并获取对应记录

## 5.2 运行时 GPU 代码生成
- 使用数据并行原语构建工作流程
- 调整 GPU 代码生成技术，在 GPU 程序中嵌入用户定义的逻辑

## 5.3 并行转化和可视化
- 如图，通过数据并行原语，构成数据转化和可视化中的每个操作

# 六、实现
- 基于 WebGL 1.0

# 七、性能基准
- 性能：和四个经典的数据转化和可视化库进行比较
	![](/images/blogs/vis/P411.png)
- 可移植性：用四种不同等级的 GPU
	![](/images/blogs/vis/P412.png)

## 7.1 方法
- 问题：浏览器的对 GPU API 的调用是异步非阻塞的。需要一种方法在 CPU 和 GPU 之间进行同步，测量实际执行时间。

## 7.2 数据传输性能
![](/images/blogs/vis/P415.png)
![](/images/blogs/vis/P416.png)

## 7.3 可视化性能
![](/images/blogs/vis/P413.png)
![](/images/blogs/vis/P414.png)

# 我的感受
- 初读 D3、P4 这一类技术类文章，收获了很多知识
- 编程接口考虑很周到
- 感知增强技术的使用

